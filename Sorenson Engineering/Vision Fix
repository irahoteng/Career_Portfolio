(* Filter to improve object recognition*)
eState := fbCamera.GetState();
CASE nCameraState OF
0: IF bRun THEN
	nCameraState := 10;
END_IF
10: 	IF eState = TCVN_CS_ERROR THEN
		 hr := fbCamera.Reset();
	ELSIF eState < TCVN_CS_ACQUIRING THEN
		hr := fbCamera.StartAcquisition();
	ELSIF eState = TCVN_CS_ACQUIRING THEN
		hr := fbCamera.GetCurrentImage(ipImageIn);
		IF SUCCEEDED(hr) AND ipImageIn <> 0 THEN
			hr := F_VN_GaussianFilter(
    			ipSrcImage      :=  ipImageIn,
   				 ipDestImage     :=  ipImageIn,
  				  nFilterWidth    :=  7,
    				nFilterHeight   :=  7,
   					 hrPrev          :=  hr 
);
			hr := F_VN_GetPixelFormat(ipImageIn, stPixelFormat, hr);
			IF stPixelFormat.nChannels = 1  THEN
				hr := F_VN_CopyIntoDisplayableImage(ipImageIn, ipImageInDisp, hr);
				hr := F_VN_ConvertColorSpace(ipImageIn,ipImageColor,  TCVN_CST_GRAY_TO_RGB,hr);
			END_IF
		
			
			nCameraState := 15;
		END_IF
		END_IF	
		
	
	15:		stBlobParams.bFilterByArea         := TRUE;
    		 stBlobParams.fMinArea              := 100;
     		stBlobParams.fMaxArea              := 10000;
   	  		stBlobParams.bFilterByCircularity  := TRUE;
     		stBlobParams.fMinCircularity       := 0.65;
     		stBlobParams.fMinThreshold         := 18;
			stBlobParams.fMaxThreshold  		:= 45;
    		 stBlobParams.fThresholdStep        := 2;
		
			 	hr := F_VN_DetectBlobs(
 			   ipSrcImage      :=  ipImageIn,
  			  ipBlobContours  :=  ipContour,
    		stParams        :=  stBlobParams,
    		hrPrev          :=  hr
);
		
		 
		
			hrWD := F_VN_StopWatchdog(hrWD, tRest => tRest, nFractionProcessed => nFraction);	  
			hr := F_VN_DrawContours(ipContour, -1, ipImageColor, aColor_Red, 3, hr); 

sText := CONCAT(CONCAT('Processed ', UDINT_TO_STRING(nFraction)), '%');
hr := F_VN_PutTextExp(sText, ipImageColor, 25, 50, TCVN_FT_HERSHEY_SIMPLEX, 1.3, aColor_Red, 2, TCVN_LT_8_CONNECTED, FALSE, hr);

sText := CONCAT(CONCAT('Time ', DINT_TO_STRING(tStop - tRest)), 'us');
hr := F_VN_PutTextExp(sText, ipImageColor, 25, 100, TCVN_FT_HERSHEY_SIMPLEX, 1.3, aColor_Red, 2, TCVN_LT_8_CONNECTED, FALSE,hr);

sText := CONCAT('Returncode ', DINT_TO_STRING(hrFunc));
hr := F_VN_PutTextExp(sText, ipImageColor, 25, 150, TCVN_FT_HERSHEY_SIMPLEX, 1.3, aColor_Red, 2, TCVN_LT_8_CONNECTED, FALSE,hr); 
nCameraState := 20;
	20:		hr := F_VN_CopyImage(ipImageColor, ipImageFiltered,hr); //apply contour before filter?
			hr := F_VN_CopyImage(ipImageColor, ipImageTest,hr);
			hr := F_VN_TransformIntoDisplayableImage(ipImageTest, ipImageResDisp, hr);
			nCameraState := 25; 
	25:
				hr := F_VN_Threshold(
					ipSrcImage := ipImageFiltered,
					ipDestImage := ipImageFiltered,
					fThreshold := 30,
					fMaxValue := 255,
					eThresholdType := TCVN_TT_BINARY,
					hrPrev := hr
				);					
				hr := F_VN_CopyIntoDisplayableImage(ipImageFiltered, ipImageFilteredDisp, hr);
				hr := F_VN_CopyImage(ipImageFiltered,ipFunImage, hr);			
				hr := F_VN_TransformIntoDisplayableImage(ipFunImage, ipImageColorDisp, hr);		
				nCameraState := 100;
	
	


	
100:	  bRun := FALSE;		
		  Done := TRUE;
		  mFilterImage := TRUE;
		  nCameraState := 0; 
END_CASE

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
(*Mask to improve region of interest aka ROI so uneeded parts aren't detected aka reduces false detections*)
eState := fbCamera.GetState();
CASE nMaskState OF
0: IF bRun THEN
	nMaskState := 10;
END_IF
10: 	IF eState = TCVN_CS_ERROR THEN
		 hr := fbCamera.Reset();
	ELSIF eState < TCVN_CS_ACQUIRING THEN
		hr := fbCamera.StartAcquisition();
	ELSIF eState = TCVN_CS_ACQUIRING THEN
		hr := fbCamera.GetCurrentImage(ipMaskingImageIn);
		IF SUCCEEDED(hr) AND ipImageIn <> 0 THEN
			hr := F_VN_GaussianFilter(
    			ipSrcImage      :=  ipMaskingImageIn,
   				 ipDestImage     :=  ipMaskingImageIn,
  				  nFilterWidth    :=  7,
    				nFilterHeight   :=  7,
   					 hrPrev          :=  hr 
);
			hr := F_VN_GetPixelFormat(ipImageIn, stPixelFormat, hr);
			IF stPixelFormat.nChannels = 1  THEN
				hr := F_VN_CopyIntoDisplayableImage(ipMaskingImageIn, ipImageMaskDisp, hr);
				hr := F_VN_ConvertColorSpace(ipMaskingImageIn,ipImageMaskColor,  TCVN_CST_GRAY_TO_RGB,hr);
				hr := F_VN_TransformIntoDisplayableImage(ipImageMaskColor, ipColorTestDisp, hr);
				//hr := F_VN_CopyImage(ipImageMaskColor,ipImageMask, hr);	
			END_IF
		
			
			nMaskState := 15;
		END_IF
		END_IF
15: hr := F_VN_GetImageWidth(ipMaskingImageIn, nWidth,hr);
	hr := F_VN_GetImageHeight(ipMaskingImageIn, nHeight, hr);
	aCenter[1] := LREAL_TO_UDINT((nWidth/2)) + aCenterOffset[0];
	aCenter[2] := (nHeight /2) + aCenterOffset[1];
	nRadius := (MIN(nWidth, nHeight)/2) - nCircleShrink;
	
	hr := F_VN_CreateImageAndSetPixels(ipImageMask, nWidth, nHeight,TCVN_ET_USINT, 1,aColor_Red, hr);
	hr := F_VN_DrawCircle(
		nCenterX := LREAL_TO_UDINT(aCenter[1]),
		nCenterY := LREAL_TO_UDINT(aCenter[2]),
		nRadius := nRadius,
		ipDestImage := ipImageMask,
		aColor	:= aColor_Red,
		nThickness := 0,
		hrPrev := hr
	);	
	nMaskState := 20;
	
20:	//hr := F_VN_CopyImage(ipImageMask,ipImageMaskTest, hr);
	hr := F_VN_TransformIntoDisplayableImage(ipImageMask, ipImageMaskDisp, hr);
	nMaskState := 100;
	
100: bRun := FALSE;
	 MaskDone := TRUE;
	 mMask := TRUE;
	 nMaskState := 0;
		
END_CASE
(* run state that cyclically calls these methods so that these filters are constantly being applied to the vision algorithm of the machine*)
CASE nRunState OF
0:	IF bExecute THEN
		nRunState := 5;
	END_IF
	
5: IF mFilterImage(TRUE) THEN
		nRunState := 10;
	END_IF
	
10: IF mMask(TRUE) THEN
		nRunState := 15;
END_IF

15: mRun := TRUE;
	nRunState := 0;
END_CASE

